name: Deploy to Server

on:
  push:
    branches: [ "main" ]

jobs:
  deploy:
    runs-on: ubuntu-latest

    steps:
    - name: Checkout code
      uses: actions/checkout@v3

    # 1. 打包源码 (排除不必要的文件)
    # 我们改用“传输源码，在服务器构建”的策略，以解决大文件 SCP 传输失败的问题
    - name: Tar source code
      run: |
        tar -czf deploy.tar.gz \
          --exclude='.git' \
          --exclude='deploy.tar.gz' \
          --exclude='tc-backend/target' \
          --exclude='tc_frontend/node_modules' \
          --exclude='tc_frontend/dist' \
          .

    # 2. 传输源码压缩包到服务器
    - name: Copy source via SSH
      uses: appleboy/scp-action@master
      with:
        host: ${{ secrets.HOST }}
        username: ${{ secrets.USERNAME }}
        password: ${{ secrets.PASSWORD }}
        # key: ${{ secrets.SSH_KEY }}
        source: "deploy.tar.gz"
        target: "/opt/tc-project"
        timeout: 120s

    # 3. 在服务器解压并构建运行
    - name: Deploy on Server
      uses: appleboy/ssh-action@master
      with:
        host: ${{ secrets.HOST }}
        username: ${{ secrets.USERNAME }}
        password: ${{ secrets.PASSWORD }}
        # key: ${{ secrets.SSH_KEY }}
        script: |
          cd /opt/tc-project
          
          # 解压源码
          tar -xzf deploy.tar.gz
          rm deploy.tar.gz
          
          # 停止旧容器
          docker compose down
          
          # 重新构建并启动 (Docker 会自动下载 Maven/Node 镜像进行构建)
          # 这会消耗服务器 CPU，但避免了网络传输大文件的问题
          docker compose up -d --build
          
          # 清理虚悬镜像
          docker image prune -f
